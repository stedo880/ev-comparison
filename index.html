<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EV Comparison - Parallel Coordinates</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }

        header {
            background: #16213e;
            padding: 20px 40px;
            border-bottom: 1px solid #0f3460;
        }

        h1 {
            font-size: 1.8rem;
            font-weight: 600;
            color: #e94560;
        }

        h1 span {
            color: #eee;
            font-weight: 400;
        }

        .subtitle {
            color: #888;
            margin-top: 5px;
            font-size: 0.9rem;
        }

        .controls {
            background: #16213e;
            padding: 15px 40px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
            border-bottom: 1px solid #0f3460;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            font-size: 0.85rem;
            color: #aaa;
        }

        select, button {
            background: #0f3460;
            border: 1px solid #1a1a2e;
            color: #eee;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
        }

        select:hover, button:hover {
            background: #1a4a7a;
        }

        button.active {
            background: #e94560;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 15px 40px;
            background: #16213e;
            border-bottom: 1px solid #0f3460;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .legend-item:hover {
            background: #0f3460;
        }

        .legend-item.dimmed {
            opacity: 0.3;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        #chart {
            width: 100%;
            height: calc(100vh - 220px);
            min-height: 500px;
        }

        .axis text {
            font-size: 11px;
            fill: #aaa;
        }

        .axis .domain {
            stroke: #444;
        }

        .axis-label {
            font-size: 12px;
            font-weight: 600;
            fill: #e94560;
            cursor: pointer;
        }

        .axis-label:hover {
            fill: #ff6b6b;
        }

        .foreground path {
            fill: none;
            stroke-width: 1.5;
            stroke-opacity: 0.7;
            transition: stroke-opacity 0.2s;
            pointer-events: none;
        }

        .hitarea path {
            fill: none;
            stroke-width: 20;
            stroke: transparent;
            pointer-events: stroke;
            cursor: pointer;
        }

        /* Narrower hitarea on touch for more precise selection */
        @media (pointer: coarse) {
            .hitarea path {
                stroke-width: 8;
            }
        }

        .foreground path:hover {
            stroke-width: 3;
            stroke-opacity: 1;
        }

        .foreground path.dimmed {
            stroke-opacity: 0.05;
        }

        /* When a path is selected, dim other non-filtered paths */
        .foreground.has-selection path:not(.highlighted):not(.dimmed) {
            stroke-opacity: 0.25;
        }

        .foreground path.highlighted {
            stroke-width: 3;
            stroke-opacity: 1;
        }

        .foreground path.selected {
            stroke-width: 4;
            stroke-opacity: 1;
        }

        /* Touch device optimizations */
        @media (pointer: coarse) {
            .tooltip {
                bottom: 60px;
                font-size: 0.9rem;
                padding: 15px 20px;
            }

            .tooltip-title {
                font-size: 1.1rem;
            }

            /* Wider stroke for easier touch targeting */
            .foreground path {
                stroke-width: 3;
            }

            .foreground path.dimmed {
                stroke-width: 2;
            }

            /* Larger touch targets for controls */
            select, button {
                padding: 12px 16px;
                font-size: 1rem;
            }

            .legend-item {
                padding: 8px 12px;
                font-size: 0.9rem;
            }

            .legend-color {
                width: 16px;
                height: 16px;
            }

            header {
                padding: 15px 20px;
            }

            .controls {
                padding: 12px 20px;
            }

            .legend {
                padding: 12px 20px;
            }
        }

        .brush .selection {
            fill: #00bcd4;
            fill-opacity: 0.3;
            stroke: #00bcd4;
        }

        .tooltip {
            position: fixed;
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);
            background: #16213e;
            border: 1px solid #0f3460;
            border-radius: 6px;
            padding: 12px 20px;
            font-size: 0.85rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            max-width: 95vw;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip-title {
            font-weight: 600;
            color: #e94560;
            margin-bottom: 8px;
            text-align: center;
        }

        .tooltip-content {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px 20px;
        }

        .tooltip-row {
            display: flex;
            gap: 6px;
            white-space: nowrap;
        }

        .tooltip-label {
            color: #888;
        }

        .tooltip-value {
            color: #eee;
            font-weight: 500;
        }

    </style>
</head>
<body>
    <header>
        <h1>EV Comparison <span>Parallel Coordinates</span></h1>
        <p class="subtitle">Interactive visualization of electric vehicles available in Sweden H1 2026</p>
    </header>

    <div class="controls">
        <div class="control-group">
            <label>Color by:</label>
            <select id="colorBy">
                <option value="make">Make</option>
                <option value="drive">Drive Type</option>
                <option value="seats">Seats</option>
            </select>
        </div>
        <div class="control-group">
            <label>Highlight:</label>
            <select id="highlight">
                <option value="">None</option>
            </select>
        </div>
        <div class="control-group">
            <button id="resetBrush">Reset Filters</button>
        </div>
        <div class="control-group">
            <button id="deselectAll">Hide All</button>
            <button id="selectAll">Show All</button>
        </div>
    </div>

    <div class="legend" id="legend"></div>

    <svg id="chart"></svg>

    <div class="tooltip" id="tooltip"></div>


    <script>
        // Load and parse YAML data
        async function loadData() {
            const response = await fetch('evs.yaml');
            const yamlText = await response.text();
            const data = jsyaml.load(yamlText);
            return data.evs;
        }

        // Main visualization
        async function init() {
            const rawData = await loadData();

            // Process data - clean numeric values
            // Helper to parse values that may have ~ prefix (approximate) or be null
            const parseNum = (val) => {
                if (val == null) return 0;
                return parseFloat(String(val).replace('~', '')) || 0;
            };

            const data = rawData.map((d, i) => ({
                id: i,
                name: `${d.make} ${d.model}${d.submodel ? ' ' + d.submodel : ''}`,
                make: d.make,
                model: d.model,
                submodel: d.submodel || '',
                year: d.year,
                price_sek: parseNum(d.price_sek),
                range_km_wltp: parseNum(d.range_km_wltp),
                battery_kwh: parseNum(d.battery_kwh),
                dc_charge_max_kw: parseNum(d.dc_charge_max_kw),
                charge_10_80_min: parseNum(d.charge_10_80_min),
                power_hp: parseNum(d.power_hp),
                acceleration_0_100: parseNum(d.acceleration_0_100),
                top_speed_kmh: parseNum(d.top_speed_kmh),
                drive: d.drive || 'Unknown',
                cargo_liters: parseNum(d.cargo_liters),
                seats: d.seats || 5,
                tow_capacity_kg: parseNum(d.tow_capacity_kg),
                notes: d.notes || ''
            }));

            // Dimensions for parallel coordinates
            const dimensions = [
                { key: 'price_sek', label: 'Price (SEK)', format: d => d3.format(',.0f')(d), invert: true },
                { key: 'range_km_wltp', label: 'Range (km)', format: d => d3.format(',.0f')(d) },
                { key: 'battery_kwh', label: 'Battery (kWh)', format: d => d3.format('.0f')(d) },
                { key: 'dc_charge_max_kw', label: 'DC Charge (kW)', format: d => d3.format('.0f')(d) },
                { key: 'charge_10_80_min', label: '10-80% (min)', format: d => d3.format('.0f')(d), invert: true },
                { key: 'power_hp', label: 'Power (hp)', format: d => d3.format(',.0f')(d) },
                { key: 'acceleration_0_100', label: '0-100 (s)', format: d => d3.format('.1f')(d), invert: true },
                { key: 'cargo_liters', label: 'Cargo (L)', format: d => d3.format(',.0f')(d) },
                { key: 'tow_capacity_kg', label: 'Tow (kg)', format: d => d3.format(',.0f')(d) }
            ];

            // Color scales
            const makes = [...new Set(data.map(d => d.make))].sort();
            const drives = [...new Set(data.map(d => d.drive))].sort();
            const seatOptions = [...new Set(data.map(d => d.seats))].sort((a, b) => a - b);

            // Brand-inspired colors (while maintaining visual distinction)
            const brandColorMap = {
                'Audi': '#e30613',      // Audi red
                'BMW': '#0066cc',       // BMW blue
                'Hyundai': '#00aad2',   // Hyundai cyan
                'Kia': '#ff7043',       // Kia - orange (differentiated from reds)
                'Mercedes-Benz': '#a0a0a0', // Mercedes silver
                'Peugeot': '#5c6bc0',   // Peugeot - indigo/purple-blue
                'Polestar': '#b0e0e6',  // Polestar ice blue
                'Porsche': '#8b0035',   // Porsche - burgundy (differentiated)
                'Renault': '#ffd600',   // Renault yellow
                'Skoda': '#4ba82e',     // Skoda green
                'Subaru': '#1a73e8',    // Subaru blue
                'Tesla': '#e91e63',     // Tesla - magenta-red (differentiated)
                'Toyota': '#ff5722',    // Toyota - deep orange
                'Volkswagen': '#1a237e', // VW dark blue
                'Volvo': '#607d8b'      // Volvo blue-grey
            };
            const makeColors = d3.scaleOrdinal()
                .domain(makes)
                .range(makes.map(m => brandColorMap[m] || '#888888'));

            const driveColors = d3.scaleOrdinal()
                .domain(drives)
                .range(['#e94560', '#00d9ff', '#ffc107']);

            const seatColors = d3.scaleOrdinal()
                .domain(seatOptions)
                .range(['#00d9ff', '#e94560', '#ffc107']);

            let colorScale = makeColors;
            let colorKey = 'make';
            let invertPrice = false;

            // Setup SVG
            const svg = d3.select('#chart');
            const margin = { top: 50, right: 60, bottom: 30, left: 80 };

            function getSize() {
                const rect = svg.node().getBoundingClientRect();
                return {
                    width: rect.width - margin.left - margin.right,
                    height: rect.height - margin.top - margin.bottom
                };
            }

            let { width, height } = getSize();

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Scales
            const x = d3.scalePoint()
                .domain(dimensions.map(d => d.key))
                .range([0, width]);

            const y = {};
            const zeroBasedKeys = ['price_sek', 'range_km_wltp', 'battery_kwh', 'dc_charge_max_kw', 'power_hp', 'cargo_liters', 'tow_capacity_kg'];
            dimensions.forEach(dim => {
                const extent = d3.extent(data, d => d[dim.key]);
                // Add padding at top
                const padding = (extent[1] - extent[0]) * 0.05;
                const minVal = zeroBasedKeys.includes(dim.key) ? 0 : extent[0] - padding;
                y[dim.key] = d3.scaleLinear()
                    .domain([minVal, extent[1] + padding])
                    .range(dim.invert && (dim.key !== 'price_sek' || invertPrice) ? [0, height] : [height, 0]);
            });

            // Line generator
            function path(d) {
                return d3.line()(dimensions.map(dim => [x(dim.key), y[dim.key](d[dim.key])]));
            }

            // Brushes
            const brushes = {};
            const brushSelections = {};

            // Draw paths
            const foreground = g.append('g')
                .attr('class', 'foreground');

            // Draw invisible hit areas for easier hover
            const hitarea = g.append('g')
                .attr('class', 'hitarea');

            // Detect touch device
            const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            let selectedPath = null;


            const paths = foreground.selectAll('path')
                .data(data)
                .join('path')
                .attr('d', path)
                .attr('stroke', d => colorScale(d[colorKey]));

            // Hit area paths for hover/touch detection
            const hitPaths = hitarea.selectAll('path')
                .data(data)
                .join('path')
                .attr('d', path)
                .on('mouseover', showTooltip)
                .on('mousemove', moveTooltip)
                .on('mouseout', hideTooltip);

            // Touch events on hitPaths
            if (isTouchDevice) {
                hitPaths.each(function(d) {
                    this.addEventListener('touchstart', (event) => handleTouch(event, d), { passive: true });
                });
            }

            // Draw axes
            const axes = g.selectAll('.axis')
                .data(dimensions)
                .join('g')
                .attr('class', 'axis')
                .attr('transform', d => `translate(${x(d.key)},0)`);

            axes.each(function(dim) {
                const axis = d3.axisLeft(y[dim.key])
                    .ticks(6)
                    .tickFormat(dim.format);
                d3.select(this).call(axis);
            });

            // Axis labels
            axes.append('text')
                .attr('class', 'axis-label')
                .attr('y', -12)
                .attr('text-anchor', 'middle')
                .text(d => d.label)
                .on('click', function(event, d) {
                    if (d.key === 'price_sek') {
                        invertPrice = !invertPrice;
                        updateAxes();
                    }
                });

            // Brushes
            function updateBrush(dim) {
                return d3.brushY()
                    .extent([[-10, 0], [10, height]])
                    .on('brush end', function(event) {
                        if (event.selection) {
                            brushSelections[dim.key] = event.selection;
                        } else {
                            delete brushSelections[dim.key];
                        }
                        updatePaths();
                    });
            }

            axes.append('g')
                .attr('class', 'brush')
                .each(function(dim) {
                    brushes[dim.key] = updateBrush(dim);
                    d3.select(this).call(brushes[dim.key]);
                })
                .on('dblclick', function(event, dim) {
                    // Double-click to clear brush on this axis
                    d3.select(this).call(brushes[dim.key].move, null);
                    delete brushSelections[dim.key];
                    updatePaths();
                });

            // Long-press to clear brush (for touch devices)
            let longPressTimer = null;
            let longPressTarget = null;

            axes.selectAll('.brush')
                .on('touchstart', function(event, dim) {
                    longPressTarget = { element: this, dim: dim };
                    longPressTimer = setTimeout(() => {
                        if (longPressTarget && brushSelections[dim.key]) {
                            d3.select(longPressTarget.element).call(brushes[dim.key].move, null);
                            delete brushSelections[dim.key];
                            updatePaths();
                        }
                        longPressTarget = null;
                    }, 500); // 500ms long press
                }, { passive: true })
                .on('touchend touchmove', function() {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                }, { passive: true });

            function updatePaths() {
                const isFiltered = d => {
                    return Object.entries(brushSelections).some(([key, sel]) => {
                        const val = y[key](d[key]);
                        return val < sel[0] || val > sel[1];
                    });
                };
                paths.classed('dimmed', isFiltered);
                // Disable touch/click on filtered hitarea paths
                hitPaths.style('pointer-events', d => isFiltered(d) ? 'none' : null);
            }

            function updateAxes() {
                dimensions.forEach(dim => {
                    const extent = d3.extent(data, d => d[dim.key]);
                    const padding = (extent[1] - extent[0]) * 0.05;
                    const minVal = zeroBasedKeys.includes(dim.key) ? 0 : extent[0] - padding;
                    y[dim.key] = d3.scaleLinear()
                        .domain([minVal, extent[1] + padding])
                        .range(dim.invert && (dim.key !== 'price_sek' || invertPrice) ? [0, height] : [height, 0]);
                });

                axes.each(function(dim) {
                    const axis = d3.axisLeft(y[dim.key])
                        .ticks(6)
                        .tickFormat(dim.format);
                    d3.select(this).call(axis);
                });

                // Update brushes
                axes.selectAll('.brush').each(function(dim) {
                    brushes[dim.key] = updateBrush(dim);
                    d3.select(this).call(brushes[dim.key]);
                });

                paths.attr('d', path);
                hitPaths.attr('d', path);
                brushSelections.length = 0;
            }

            // Tooltip
            const tooltip = d3.select('#tooltip');

            function showTooltip(event, d) {
                tooltip.classed('visible', true);
                tooltip.html(`
                    <div class="tooltip-title" style="color: ${makeColors(d.make)}">${d.name}</div>
                    <div class="tooltip-content">
                        <div class="tooltip-row"><span class="tooltip-label">Price:</span><span class="tooltip-value">${d3.format(',.0f')(d.price_sek)} SEK</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">Range:</span><span class="tooltip-value">${d.range_km_wltp} km</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">Battery:</span><span class="tooltip-value">${d.battery_kwh} kWh</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">Power:</span><span class="tooltip-value">${d.power_hp} hp</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">0-100:</span><span class="tooltip-value">${d.acceleration_0_100}s</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">Drive:</span><span class="tooltip-value">${d.drive}</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">Cargo:</span><span class="tooltip-value">${d.cargo_liters}L</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">Seats:</span><span class="tooltip-value">${d.seats}</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">Tow:</span><span class="tooltip-value">${d.tow_capacity_kg} kg</span></div>
                    </div>
                `);
                paths.classed('highlighted', p => p.id === d.id);
                foreground.classed('has-selection', true);
            }

            function moveTooltip(event) {
                // Tooltip is now fixed at bottom, no movement needed
            }

            function hideTooltip() {
                tooltip.classed('visible', false);
                paths.classed('highlighted', false);
                foreground.classed('has-selection', false);
            }

            // Touch handling for iPad/mobile
            function handleTouch(event, d) {
                event.stopPropagation();

                // Clear previous selection
                if (selectedPath) {
                    paths.classed('selected', false);
                }

                // Select this path
                selectedPath = d;
                d3.select(event.currentTarget).classed('selected', true);

                // Show tooltip
                tooltip.classed('visible', true);
                tooltip.html(`
                    <div class="tooltip-title" style="color: ${makeColors(d.make)}">${d.name}</div>
                    <div class="tooltip-content">
                        <div class="tooltip-row"><span class="tooltip-label">Price:</span><span class="tooltip-value">${d3.format(',.0f')(d.price_sek)} SEK</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">Range:</span><span class="tooltip-value">${d.range_km_wltp} km</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">Battery:</span><span class="tooltip-value">${d.battery_kwh} kWh</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">Power:</span><span class="tooltip-value">${d.power_hp} hp</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">0-100:</span><span class="tooltip-value">${d.acceleration_0_100}s</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">Drive:</span><span class="tooltip-value">${d.drive}</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">Cargo:</span><span class="tooltip-value">${d.cargo_liters}L</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">Seats:</span><span class="tooltip-value">${d.seats}</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">Tow:</span><span class="tooltip-value">${d.tow_capacity_kg} kg</span></div>
                    </div>
                `);

                // Highlight this path, dim others
                paths.classed('highlighted', p => p.id === d.id);
                foreground.classed('has-selection', true);
            }

            // Dismiss tooltip when single-tapping elsewhere (not pinch/zoom)
            let touchStartTime = 0;
            let touchStartPos = null;
            document.addEventListener('touchstart', function(event) {
                // Ignore multi-touch gestures (pinch/zoom)
                if (event.touches.length > 1) {
                    touchStartPos = null;
                    return;
                }
                touchStartTime = Date.now();
                touchStartPos = { x: event.touches[0].clientX, y: event.touches[0].clientY };
            }, { passive: true });

            document.addEventListener('touchend', function(event) {
                // Only dismiss on quick single taps (not drags or multi-touch)
                if (!touchStartPos) return;
                if (event.changedTouches.length !== 1) return;

                const touchDuration = Date.now() - touchStartTime;
                const touch = event.changedTouches[0];
                const moveDistance = Math.hypot(touch.clientX - touchStartPos.x, touch.clientY - touchStartPos.y);

                // Must be a quick tap (< 300ms) with minimal movement (< 10px)
                if (touchDuration > 300 || moveDistance > 10) {
                    touchStartPos = null;
                    return;
                }

                const target = touch.target;
                const isPath = target.tagName === 'path' && (target.closest('.foreground') || target.closest('.hitarea'));
                const isTooltip = target.closest('.tooltip');
                const isControl = target.closest('.controls') || target.closest('.legend') || target.closest('select') || target.closest('button');

                // Close tooltip when tapping anywhere outside paths/tooltip/controls
                if (!isPath && !isTooltip && !isControl) {
                    selectedPath = null;
                    paths.classed('selected', false).classed('highlighted', false);
                    foreground.classed('has-selection', false);
                    tooltip.classed('visible', false);
                }
                touchStartPos = null;
            }, { passive: true });

            // Legend
            function updateLegend() {
                const legend = d3.select('#legend');
                legend.html('');

                let categories;
                if (colorKey === 'make') categories = makes;
                else if (colorKey === 'drive') categories = drives;
                else categories = seatOptions;

                // Track hidden categories
                if (!window.hiddenCategories) {
                    window.hiddenCategories = new Set();
                }

                legend.selectAll('.legend-item')
                    .data(categories)
                    .join('div')
                    .attr('class', d => `legend-item${window.hiddenCategories.has(d) ? ' dimmed' : ''}`)
                    .html(d => `<div class="legend-color" style="background:${colorScale(d)}"></div><span>${d}</span>`)
                    .on('click', function(event, cat) {
                        const item = d3.select(this);
                        const isCurrentlyHidden = window.hiddenCategories.has(cat);

                        if (isCurrentlyHidden) {
                            // Show this category
                            window.hiddenCategories.delete(cat);
                            item.classed('dimmed', false);
                        } else {
                            // Hide this category
                            window.hiddenCategories.add(cat);
                            item.classed('dimmed', true);
                        }

                        // Update path visibility (both foreground and hitarea)
                        paths.each(function(d, i) {
                            if (d[colorKey] === cat) {
                                d3.select(this).style('display', isCurrentlyHidden ? null : 'none');
                                d3.select(hitPaths.nodes()[i]).style('display', isCurrentlyHidden ? null : 'none');
                            }
                        });

                        // Re-apply brush filters after showing
                        if (isCurrentlyHidden) {
                            updatePaths();
                        }
                    });
            }

            // Color by dropdown
            d3.select('#colorBy').on('change', function() {
                colorKey = this.value;
                if (colorKey === 'make') colorScale = makeColors;
                else if (colorKey === 'drive') colorScale = driveColors;
                else colorScale = seatColors;

                // Reset hidden categories when changing color scheme
                window.hiddenCategories = new Set();
                paths.style('display', null);
                hitPaths.style('display', null);

                paths.attr('stroke', d => colorScale(d[colorKey]));
                updateLegend();

                // Re-apply brush filters
                updatePaths();
            });

            // Highlight dropdown
            const highlightSelect = d3.select('#highlight');
            highlightSelect.selectAll('option.car')
                .data(data)
                .join('option')
                .attr('class', 'car')
                .attr('value', d => d.id)
                .text(d => d.name);

            highlightSelect.on('change', function() {
                const val = this.value;
                if (val === '') {
                    paths.classed('highlighted', false).classed('dimmed', false);
                    foreground.classed('has-selection', false);
                } else {
                    paths.classed('highlighted', d => d.id === +val)
                        .classed('dimmed', d => d.id !== +val);
                    foreground.classed('has-selection', true);
                }
            });

            // Reset button
            d3.select('#resetBrush').on('click', function() {
                Object.keys(brushSelections).forEach(k => delete brushSelections[k]);
                axes.selectAll('.brush').each(function(dim) {
                    d3.select(this).call(brushes[dim.key].move, null);
                });
                // Reset hidden categories
                window.hiddenCategories = new Set();
                paths.classed('dimmed', false).classed('selected', false).classed('highlighted', false).style('display', null);
                hitPaths.style('display', null).style('pointer-events', null);
                d3.selectAll('.legend-item').classed('dimmed', false);
                d3.select('#highlight').property('value', '');
                tooltip.classed('visible', false);
                foreground.classed('has-selection', false);
                selectedPath = null;
            });

            // Invert price axis
            d3.select('#toggleInvert').on('click', function() {
                invertPrice = !invertPrice;
                d3.select(this).classed('active', !invertPrice);
                updateAxes();
            });

            // Hide All button
            d3.select('#deselectAll').on('click', function() {
                let categories;
                if (colorKey === 'make') categories = makes;
                else if (colorKey === 'drive') categories = drives;
                else categories = seatOptions;

                // Add all categories to hidden set
                categories.forEach(cat => window.hiddenCategories.add(cat));

                // Hide all paths
                paths.style('display', 'none');
                hitPaths.style('display', 'none');

                // Update legend visuals
                d3.selectAll('.legend-item').classed('dimmed', true);
            });

            // Show All button
            d3.select('#selectAll').on('click', function() {
                // Clear hidden categories
                window.hiddenCategories = new Set();

                // Show all paths
                paths.style('display', null);
                hitPaths.style('display', null);

                // Update legend visuals
                d3.selectAll('.legend-item').classed('dimmed', false);

                // Re-apply brush filters
                updatePaths();
            });

            // Initial render
            updateLegend();

            // Resize handler
            window.addEventListener('resize', () => {
                const newSize = getSize();
                width = newSize.width;
                height = newSize.height;

                x.range([0, width]);
                dimensions.forEach(dim => {
                    y[dim.key].range(dim.invert && (dim.key !== 'price_sek' || invertPrice) ? [0, height] : [height, 0]);
                });

                axes.attr('transform', d => `translate(${x(d.key)},0)`);
                axes.each(function(dim) {
                    const axis = d3.axisLeft(y[dim.key]).ticks(6).tickFormat(dim.format);
                    d3.select(this).call(axis);
                });
                axes.selectAll('.brush').each(function(dim) {
                    brushes[dim.key].extent([[-10, 0], [10, height]]);
                    d3.select(this).call(brushes[dim.key]);
                });
                paths.attr('d', path);
                hitPaths.attr('d', path);
            });
        }

        init();
    </script>
</body>
</html>
